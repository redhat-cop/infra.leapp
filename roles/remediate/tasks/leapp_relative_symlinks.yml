---
- name: leapp_relative_symlinks | Continue when leapp report is missing
  ansible.builtin.debug:
    msg: "Leapp report missing. Skipping this task."
  when: leapp_report_missing | default(false)

- name: leapp_relative_symlinks | Change symbolic links in root directory to be relative
  when: not leapp_report_missing | default(false)
  vars:
    entry_title: Upgrade requires links in root directory to be relative
    remediation_matches: "{{ leapp_report_data.entries | selectattr('title', 'match', entry_title) |
      map(attribute='detail.remediations') | flatten | list }}"
    remediation: "{{ remediation_matches | selectattr('type', 'eq', 'command') | first
      if remediation_matches | length > 0 else {} }}"
  block:
    - name: leapp_relative_symlinks | End execution of playbook if no entry found in leapp report
      ansible.builtin.debug:
        msg: "No matching entry found in leapp report. Skipping this task."
      when: remediation | length == 0

    - name: leapp_relative_symlinks | Process remediation
      when: remediation | length > 0
      block:
        - name: leapp_relative_symlinks | Output command to be executed
          ansible.builtin.debug:
            msg: "{{ remediation.context }}"

        # The old version passed the list directly to the command.  I didn't think
        # this was possible.  Guard against something weird here.  Assume non-string
        # is a list.
        - name: leapp_relative_symlinks | Set links in root directory to be relative
          ansible.builtin.command:
            argv: "{{ remediation.context if not remediation.context is string else omit }}"
            cmd: "{{ remediation.context if remediation.context is string else omit }}"
          register: leapp_relative_symlinks
          changed_when: leapp_relative_symlinks is success

...

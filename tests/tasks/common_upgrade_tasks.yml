---
# Common upgrade test tasks that can be included in any upgrade test
# TODO: This is a hack to remove leapp packages before each test to ensure role will install it.
# This is usually due to the fact that we are not using the right repository for the test, which
# causes e.g. rhel 8 packages to have a later N-V-R than rhel 9 packages.
- name: common_upgrade_tasks | Remove leapp packages
  ansible.builtin.package:
    name: "{{ leapp_remove_test_packages }}"
    state: absent

- name: common_upgrade_tasks | Gather setup tasks
  ansible.builtin.find:
    paths: "{{ playbook_dir }}/tasks/setup"
    patterns: "*.yml"
  register: setup_tasks
  delegate_to: localhost

- name: common_upgrade_tasks | Do remediation setup tasks
  ansible.builtin.include_tasks: "{{ setup_task_file }}"
  loop: "{{ setup_task_files }}"
  loop_control:
    loop_var: setup_task_file
  vars:
    setup_task_files: "{{ setup_tasks.files | map(attribute='path') | select('search', '/remediate_') | list }}"
  when:
    - setup_task_files | length > 0
    - leapp_test_remediations | d(false)

- name: common_upgrade_tasks | Do setup tasks
  ansible.builtin.include_tasks: "{{ setup_task_file }}"
  loop: "{{ setup_task_files }}"
  loop_control:
    loop_var: setup_task_file
  vars:
    setup_task_files: "{{ setup_tasks.files | map(attribute='path') | reject('search', '/remediate_') | list }}"
  when:
    - setup_task_files | length > 0
    - not (leapp_test_remediations | d(false))

- name: common_upgrade_tasks | Run first analysis
  ansible.builtin.include_role:
    name: infra.leapp.analysis
    public: true

- name: common_upgrade_tasks | Flush handlers
  ansible.builtin.meta: flush_handlers

- name: common_upgrade_tasks | Show all inhibitors collected by analysis
  ansible.builtin.debug:
    var: leapp_inhibitors | default([])

- name: common_upgrade_tasks | Debug remediation_todo
  ansible.builtin.debug:
    var: leapp_remediation_todo

- name: common_upgrade_tasks | Run remediation generated by analysis role
  when: leapp_remediation_todo | default([]) | length > 0
  block:
    - name: common_upgrade_tasks | Assert remediate hostvars, playbook, logs
      ansible.builtin.stat:
        path: "{{ item }}"
      register: remediate_hostvars_stat
      delegate_to: localhost
      failed_when: not remediate_hostvars_stat.stat.exists
      loop:
        - "{{ playbook_dir }}/host_vars/{{ inventory_hostname }}.yml"
        - "{{ playbook_dir }}/remediate.yml"
        - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_log_file_basename }}"
        - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_report_txt | basename }}"
        - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_report_json | basename }}"

    # Not running from {{ playbook_dir }}/remediate.yml because we cannot use
    # ansible.builtin.import_playbook here. import_playbook # can only be used
    # at the playbook level, not in task files.
    - name: common_upgrade_tasks | Include remediate role
      ansible.builtin.include_role:
        name: infra.leapp.remediate
        public: true

- name: common_upgrade_tasks | Gather verify remediation tasks
  ansible.builtin.find:
    paths: "{{ playbook_dir }}/tasks/verify/preupgrade"
    patterns: "remediate_*.yml"
  when: leapp_test_remediations | d(false)
  register: verify_remediation_tasks
  delegate_to: localhost

- name: common_upgrade_tasks | Verify remediations
  ansible.builtin.include_tasks: "{{ verify_remediation_task_file }}"
  loop: "{{ verify_remediation_tasks.files | map(attribute='path') | list }}"
  loop_control:
    loop_var: verify_remediation_task_file
  when: leapp_test_remediations | d(false)

- name: common_upgrade_tasks | Flush handlers
  ansible.builtin.meta: flush_handlers

- name: common_upgrade_tasks | Run analysis after remediation
  ansible.builtin.include_role:
    name: infra.leapp.analysis
    public: true

- name: common_upgrade_tasks | Flush handlers
  ansible.builtin.meta: flush_handlers

- name: common_upgrade_tasks | Assert remediate hostvars, playbook, logs
  ansible.builtin.stat:
    path: "{{ item }}"
  register: remediate_hostvars_stat
  delegate_to: localhost
  failed_when: not remediate_hostvars_stat.stat.exists
  loop:
    - "{{ playbook_dir }}/host_vars/{{ inventory_hostname }}.yml"
    - "{{ playbook_dir }}/remediate.yml"
    - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_log_file_basename }}"
    - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_report_txt | basename }}"
    - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_report_json | basename }}"

# set leapp_test_upgrade to false in order to test only analysis and remediation
- name: common_upgrade_tasks | Run upgrade role
  ansible.builtin.include_role:
    name: infra.leapp.upgrade
    public: true
  when: leapp_test_upgrade | d(true)
  tags:
    - tests::upgrade

- name: common_upgrade_tasks | Assert remediate hostvars, playbook, logs
  ansible.builtin.stat:
    path: "{{ item }}"
  register: remediate_hostvars_stat
  delegate_to: localhost
  failed_when: not remediate_hostvars_stat.stat.exists
  loop:
    - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_log_file_basename }}"
    - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_report_txt | basename }}"
    - "{{ __leapp_reports_controller_dir }}/{{ inventory_hostname }}/{{ __leapp_report_json | basename }}"

- name: common_upgrade_tasks | Gather verify postupgrade tasks
  ansible.builtin.find:
    paths: "{{ playbook_dir }}/tasks/verify/postupgrade"
    patterns: "*.yml"
  register: verify_postupgrade_tasks
  delegate_to: localhost
  when: leapp_test_upgrade | d(true)

- name: common_upgrade_tasks | Run verification tasks after upgrade
  ansible.builtin.include_tasks: "{{ verify_postupgrade_tasks_file }}"
  loop: "{{ verify_postupgrade_tasks.files | map(attribute='path') | list }}"
  loop_control:
    loop_var: verify_postupgrade_tasks_file
  when: leapp_test_upgrade | d(true)
...
